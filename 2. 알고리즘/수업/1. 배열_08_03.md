# 배열

> 일정한 자료형의 변수들을 하나의 이름으로 열거하여 사용하는 자료구조

a1 = 1; a2 = 2; a3 = 3; ..... an = n 등 수많은 데이터가 있을 경우, a = [1, 2, 3, 4, ... , n] 으로 표현



### 알고리즘

> 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
>
> 슈더코드와 순서도로 표현가능하다



### 시간복잡도

> 알고리즘의 작업량을 표현

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산



### 빅-오(O) 표기법

> 시간복잡도 함수 중 가장 큰 영향력을 주는 n에 대한 항만을 표시. 계수 생략

ex) `O(3n+2) = O(n)` `O(2n^2+10n+100) = O(n^2)` `O(4)=O(1)`

-> n개의 데이터를 입력받아 저장한 후 각 데이터에 1식 증가시킨 후 각 데이터를 출력하는 알고리즘의 시간복잡도는? `O(n)`



### 배열의 필요성

> 변수가 여럿일 경우, 일일이 다른 변수명을 이용하는 것은 매우 비효율
>
> 하나의 선언으로 둘 이상의 변수를 선언할 수 있다

- 1차원 배열

```python
# 참조형
Arr = list()
Arr = []
# 값형
a = 10
# 접근법
Arr[0] = 10 # Arr의 0번째 원소에 10 저장
Arr[idx] = 20 # Arr의 idx번째 원소에 20 저장
```



### 버블정렬

> 가벼운 것이 위로 올라간다 -> 거품이 올라가는 느낌을 생각해보자
>
> 인접한 두 값을 비교하여 자리를 계속 교환하면서 맨 마지막 자리까지 이동하는 것.

- 55, 7, 78, 12, 42를 버블정렬해보자

1 pass 에서 1, 2 번째, 2, 3번째, 3, 4번째, 4, 5번째 총 4번 비교. 마지막 값은 고정

2 pass에서 1, 2 번째, 2, 3번째, 3, 4번째 총 3번 비교. 마지막 2개값은 고정

3 pass 에서 1, 2 번째, 2, 3번째 총 2번 비교 마지막 3개값은 고정

4pass 1, 2번째 총 1번 비교. 완성. 정렬 끝

```python
def BubbleSort(a):
    for i in range(len(a)-1, 0, -1): # 4, 3, 2, 1 로 돈다. pass 의 범위를 선정해준 것.
        for j in range(0, i): # j = 0, 1, 2, 3 순서대로 대소 비교
            if a[j] > a[j+1]:
            	a[j], a[j+1] = a[j+1], a[j]
```



### 정렬의 시간복잡도

버블정렬0(n^2)

카운팅정렬 0(n+k)

선택정렬0(n^2)

퀵 정렬 0(nlogn)

삽입정렬0(n^2)

병합정렬 0(nlogn) 



#### 연습문제

```python
data = [7,4,2,0,0,6,0,7,0]
MAX = 0
# 자기자신을 기준으로 오른쪽 숫자를 찾음
# 이 중 나보다 작은 수를 찾아라
# 작은 수만큼 값이 낙차..

for i in range(9): # index0~ 8까지. 총 9개 돈다
    cnt = 0
    for j in range(i+1, 9): # index 현재 i보다는 크고 끝값까지..
        if data[i] > data[j]: # index i 기준 오른쪽 숫자중 작은 값이 있다면
            cnt += 1 # count 1개씩 늘려라
    if MAX<cnt: # 최신 cnt 값보다 max가 작으면 갱신
        MAX=cnt
print(MAX)          
```





### 카운팅솔트



```python
# 아니 이게 뭔데,,
def counting_sort(A, B, k): 
    C = [0] * k
    for i in range(0, len(B)):
        C[A[i]] += 1
        
    
    # 누적
    for i in range(1, len(C)):
        C[i] += C[i-1] # C[i]= C[i] + C[i-1]
        
    # 소트
    for i in range(len(B)-1, -1, -1):
        B[C[A[i]]-1] = A[i]
        C[A[i]] -= 1
        
a = [0, 4, 1, 3, 1, 2, 4, 1] # 소스
b = [0] * len(a) # 결과]
counting_sord(a, b, 10#대충 최대값)

pri
```



###  완전검색

> 문제해법의 모든 경우의 수를 나열해보고 확인하는 것
>
> 해답을 찾을 확률은 크지만, 시간이 오래걸림
>
> 경우의 수가 상대적으로 작을 때 유용한 방법

#### baby-gin

```python
# 완전 검색을 활용하여 6중 for문을 만들자
def babyjin(data):
    for i1 in range(6):
        if i2 in range(6):
            if i2 != i1:
                for i3 in range(6):
                    if i3 != i1 and i3 != i2:
                        for i4 in range(6):
                            if i4 != i3 and i4 != i2 and i4 != i1:
                                for i5 in range(6):
                                    if i5 != i4 and i5 != i3 and i5 != i2 and i5 != i1:
                                        for i6 in range(6):
                                            if i6 != i5 and i6 != i4 and i6 != i3 and i6 != i2 and i6 != i1:
                                                chk = 0
                                                if data[i1] == data [i2] and data[i2] == data[i3]:
                                                    chk += 1
                                                if data[i4] == data [i5] and data[i5] == data[i6]:
                                                    chk += 1
                                                if data[i1] + 1 == data[i2] and data[i2] + 1 == data[i3]:
                                                    chk += 1
                                                if data[i4] + 1 == data[i5] and data[i5] + 1 == data[i6]:
                                                    chk += 1
                                                if chk == 2:
                                                    return True
    return False
da_ta = [1, 2, 3, 4, 5, 6]
```

> n^6 만큼 시간이 걸린다. 매우 비효율적이다



#### 순열 만들기

> {1, 2, 3} 순열의 찾자!
>
> 3! = 6가지다
>
> 1 -2 -3 : 123
>
> ​	3 - 2 : 132
>
> 2 -1 -3 : 213
>
> ​	3 -1 : 231
>
> 3 -1 -2 : 312
>
> ​	2 -1 : 321

```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        if i2 != i1: # 각각 다른 것을 뽑아야하기에
            for i3 in range(1, 4):
                if i3 != i1 and i3 != i2:
                    print(i1, i2, i3)
# 원소가 3개라 3중 for문, 많으면 증가한다
```

#### 중복순열

```python
for i1 in range(1, 4):
    for i2 in range(1, 4):
        for i3 in range(1, 4):
            print(i1, i2, i3)
```





### 탐욕(greedy) 알고리즘

> 최적해를 구하는데 사용되는 근시안적인 방법
>
> 결정은 지역적으로 최적이지만, 최종적인 해답이 최적이라는 보증은 없다

- 거스름돈을 거슬러준다면?

800원 거슬러줄때, 최소한의 동전으로 거슬러주자!

현재 800원 -> 제일 처음으로 500원 줄 수 있는가? -> 가능

현재 300원 -> 500원 줄 수 있는가? -> 불가 ㅠ -> 100원은? -> 가능

현재 200원 -> 100원? -> 가능 .... 이하 반복



만약 400원짜리 동전이 생긴다면? -> 합리적 선택은 400원 * 2개! 하지만,,

현재 800원 -> 제일 처음으로 500원 줄 수 있는가? -> 가능

현재 300원 -> .... 400원이 생겼지만 탐욕 알고리즘은 이를 반영하지 못한다.



#### baby-gin

> 6개의 숫자를 정렬해보자! 되나?  안.됨.
>
> ex 123123 -> 112233 run 두개지만 정렬하면 안됨 
>
> 
>
> 그리디로 어캐 푸는가? count 해서..
>
> run 을 먼저 조사 후 데이터 완전 삭제해보기
>
> 3  1개  4 4개 5 1개
>
> 3 0개 4 3개 5 0개로 run 1개 triplete 1개 찾음
>
> 반대로 가능헌!
>
> 
>
> 456789 % 10 ? -> 9!
>
> 456789 // 10 -> 45678
>
> 45678 % 10 -> 8
>
> 45678 // 10 -> 4567
>
> 이렇게 6번 해야함; 이렇게 하면 뒷자리부터 구해나갈 수 있음
>
> 
>
> 구현 예 에서 왜 continue 썼는가?
>
> -> i +=1 안하려고

```python
# greedy 를 이용해 구현해보자
num = 456789
c = [0] * 12
for i in range(6):
    c[num % 10] += 1 # c[num % 10] = c[num % 10] + 1
    num //= 10 # num = num // 10

i = 0
tri = run = 0
while i < 10:
    if c[i] >= 3:
        c[i] -= 3
        tri += 1
        continue
    if c[i] >= 1 and c[i+1] >= 1 and c[i+2] >= 1:
        c[i] -= 1
        c[i+1] -= 1
        c[i+2] -= 1
        run += 1
        continue
    i += 1

if tri + run == 2: print("babygin")
else : print("Lose")
```





#### HW1. view



input 

100 # test_case 층수 

0 0 225 214 .... 0 0 (값 100개 앞뒤 두개씩 0)

1000

0 0 ... 

총 10가지 반복



문제상 10개의 테스트케이스 주어진다

위 문제는 testcase가 순서가 아닌 층수이기때문에

10번 도는 for 문을 만들어준다

```python
for tc in range(1, 11)
```

왜 1~ 11?!

output 이 #1 691 이런 형태라,, 1부터 10까지 나와야함

```python
N = int(input()
```

기본적으로 input 값은 str 형태이기 때문 int로 형변환해준것

-> N에는 처음 100이 들어간다.

```python
arr = list(map(int, input().split()))
```

-> 숫자들의 나열을 공백기준으로 자를 것이고, 형태는 int 로 넣을 것이다. 이 경우 type 은 map. 이걸 list 화 할 것이다.

```python
cnt = 0
```

-> 값을 저장할 변수 cnt 초기값 설정

```python
for i in range(2, N-2)
```

-> 전체 리스트  앞 2개 뒤 2개는 값이 0이라 제외됨

```python
MAX = max(arr[i-2], arr[i-1], arr[i+1], arr[i+2])
```

-> 조망권에 영향을 주는 앞뒤 두개씩 층수 중 최댓값을 구해 변수에 할당해준다. 소문자max 는 최댓값을 구해주는 내장함수. MAX는 그냥 변수이름 ㅡ.ㅡ

```python
if arr[i] > MAX:
    cnt += (arr[i]-MAX)
```

-> 위의 최댓값보다 층수가 더 클경우 그 차를 cnt 변수에 누적해서 더해주기

-> if 끝나면 다시 for(2번째) 문으로 돌아감.  다시 다음 아파트 값 계속 찾아서 다시 MAX에 넣고, if 를 또 돌려서 cnt에 또 도해줌..  언제까지? range N -2 도달하면 종료!

다 끝나면? test_case 그 다음으로 넘어가서 2번!

그리고 다음 input 으로 넘어간다 !