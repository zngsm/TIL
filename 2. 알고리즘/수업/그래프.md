# 그래프



## 그래프기본

> 아이템과 이들 사이의 연결관계를 표현
>
> 정점과 간선의 집합 구조
>
> N : N관계를 가지는 원소들을 표현하기 용이
>
> V개의 정점을 가지는 그래프는 최대 |V|(|V| - 1) / 2 간선이 가능(최대값)



### 그래프 분류

- 무향 그래프

- 유향 그래프

- 가중치그래프

- 사이클 없는 방향 그래프(DAG) : 다시 자신으로 돌아오지 않는다

- 완전 그래프 : 모든 임의의 두 정점들은 모두 `인접`된 상태(인접 : 간선으로 연결된 상태)

- 부분 그래프







- 그래프 경로

간선들을 순서대로 나열한 것

경로 중 한 정점을 한번만 지나면 -> 단순 경로

시작 점에서 끝나는 그래프 -> 사이클





- 그래프 표현

간선 정보를 저장하는 방식, 메모리나 성능을 고려해 결정

 - 인접행렬
   	- V * V 크기의 2차원ㅂ ㅐ열을 이용해 간선 정보 저장
   	- 행번호와 열번호는 그래프의 정점에 대응
   	- 두 정점이 인접되어 있으면 1 아니면 0
   	- 무향 그래프 -=> i번째 행의합 = i번째 열의합 = Vi 차수
   	- 유향 그래프 => 행 i의 합 = Vi의 진출차수 / 열 i의 합 = Vi의 진입차수
   	- 인접행렬의 단점  : 불필요한 메모리소비가 생긴다
 - 인접리스트
    - 각 정점마다 해당 정점으로 나가는 간선 정보 저장
    - 각 정점에 대한 인접 정점들을 순차적으로 표현
    - 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결리스트로 저장
    - 무향그래프 -> 노드 수 = 간선수 * 2 / 각 정 점의 노드수 = 정점의 차수
    - 방향 그래프 -> 노드수 = 간선 수 / 각 정점의 노드 수 = 정점의 진출 차수
- 간선 배열
  - 간선을 배열에 연속적으로 저장





그래프 탐색

> 비선형구조인 그래프로 모든 자료를 빠짐없이 탐색하는 것을 의미한다



- 깊이 우선 탐색

> 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더이상 갈 곳이 없게 되면, 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복해 결국 모든 정점을 방문하는 순회방법



후입선출 구조의 스택을 사용한다



스택의 특성

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조이다
- 선형구조 : 자료 간의 관계가 1대 1의 관계를 갖는다
  - 비선형구조 : 자료간의 관계가 1 대 N
- 마지막에 삽입한 자료를 가장 먼저 꺼낸다
  - 후입선출



스택의 구현

- 스택을 구현하기 위해 필요한 저장소와 연산
  - 저장소 = 스택 
  - 스택의 마지막 삽입된 원소의 위치는 top
- 연산
  - push : 저장소에 자료를 삽입한다
  - pop : 저장소에서 자료를 꺼낸다(삽입한 자료의 역순으로)
  - isEmpty : 스택이 공백인지 아닌지를 확인
  - peek : 스택의 top에 있는 item을 반환하는 연산



- 스택의 push 알고리즘
  - top은 스택에서 마지막 자료

```pseudocode
push(S, x)
	top <- top + 1;
	
	if top > STACK_SIZE
		error overflow;
	else
		S[top] <- x;
```



- 스택의 pop 알고리즘

```pseudocode
pop(S)
	if top = -1
		error underflow;
	else
		top <- top - 1;
		return S[top + 1];
```



- DFS 알고리즘 - 재귀

```pseudocode
DFS_Recursive(G, v)
	
	visited[v] <- TRUE
	FOR each all w in adjacency(G, v)
		IF visited[w] =/= TRUE
			DFS_Recursive(G, w)
```



- DFS 알고리즘 - 반복

```pseudocode
STACK s
visited []
DFS(v)
	push(s, v)
	WHILE NOT isEmpty(s)
		v <- pop(S)
		IF NOT visited[v]
			visit(v)
			FOR each w in adjacency(v)
				IF NOT visited[w]
				push(s, w)
```





- 너비 우선 탐색

> 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
>
> 인접한 정점에 대해 탐색한 후 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용



- 큐의 구조 및 기본 연산
  - 큐의 선입선출 구조
  - front - 머리(첫번째 원소) / rear - 꼬리(저장원소 중 마지막 원소)
- 큐의 기본연산
  - 삽입
  - 삭제



- 공백큐 생성 :  `createQueue()` => front = rear = -1
- 원소 A 삽입 : `enQueue(A)` => front = -1 / rear + 1 증가
- 원소 B 삽입 : `enQueue(B)` => front = -1 / rear + 1 증가
- 원소 반환/삭제 : `deQueue()` = fron += 1 / rear 그대로 (A 반환)
- 원소 C 삽입 : `enQueue(C)`; => front 그대로 / rear += 1
- 원소 반환/삭제 : `deQueue()`; => front += 1 / rear 그대로 (B 반환)
- 원소 반환/삭제 : `deQueue()`; => front += 1 / rear 그대로 (C 반환)



enQueue(item)

- 마지막 원소 뒤에 새로운 원소 삽입을 위해 rear을 하나 증가시켜 새로운 원소 삽입 자리 마련
- 해당 인덱스에 배열원소 저장

```pseudocode
EnQueue(Q, x)
	if isFull() // rear == QUEUE_SIZE
		QUEUE_FULL
	else
		rear <- rear + 1
		Q[rear] <- x
```



deQueue()

- 가장 앞에 있는 원소를 삭제하기 위해 front 값을 하나 증가시켜 QUEUE의 남은 첫번째 원소 이동
- 새로운 첫번째 원소를 리턴함으로써 삭제와 동일한 기능

```pseudocode
deQueue(Q)
	if isEmpty()
		QUEUE_EMPTY
	elose
		front <- front + 1
		return Q[front]
```



isEmpty / isFull

- 공백상태 > front == rear
- 포화상태 rear = n - 1(n: 배열의 크기, n - 1: 배열의 마지막 인덱스)



```pseudocode
isEmpty()
	IF front = rear : RETURN TRUE
	ELSE : RETURN FALSE
	
isFull()
	IF rear = n - 1 : RETURN TRUE
	ELSE : RETURN FALSE
```



BFS -> 최단거리 찾을 때 유용함



```pseudocode
BFS(G, v) // 그래프 G, 탐색 시작점 v
	큐 생성
	시작점 v를 큐에 삽입
	점 v를 방문한 것으로 표시
	WHILE 큐가 비어있지 않은 경우
		t <- 큐의 첫번째 원손 반환
		FOR t와 연결된 모든 선에 대해
			u <- t의 이웃점
			u가 방문되지 않은 곳이면, 
			u를 큐에 넣고, 방문한 것으로 표시
```



deque -> 뭐노?





서로소 집합들

> 서로소 또는 상호 배타 집합들은 서로 중복 포함된 원소가 없는 집합들 => 교집합이 없음
>
> 집합에 속한 `하나의 특정 멤버`를 통해 각 집합들을 구분한다 => `대표자`

- 연결리스트나 트리로 표현한다



상호배타 집합 예

- Make-Set(x) : x를 대표요소로 한다

```pseudocode
p[x] : 노드 x의 부모를 저장

Make-Set(x)
	p[x] <- x
```

- Find-Set(x) : x가 속해지는 그룹의 대표요소를 찾는다

```pseudocode
Find-Set(x)
	IF x == p[x]: RETURN x
	ELSE : RETURN Find-SEt(p[x])
	
// 반복구조
WHILE p[x] != x
	x <- p[x]
return x
```

- Union(x, y) : x가 대표자이고, y가 대표자인 두 그룹을 합하는 것 -> 대표는 x

```pseudocode
Union(x, y)
	p[Find-Set(y)] <- Find-Set(x)
```



상호 배타 집합 표현 - 트리

> 하나의 집합을 하나의 트리로 표현한다
>
> 자식 노드가 부모 노드를 가리키며 루트 노드가 대표자가 된다



상호배타집합에 대한 연산

- 연산의 효율을 높이는 방법
  - Rank를 이용한 Union
    - 각 노드는 자신을 루트로 하는 subtree의 높이를 Rank라는 이름으로 저장 rank가 낮은 집합을 높은 rank 집합에 붙인다
  - path compression
    - find-set을 행하는 과정에서 만나는 모든 노드들이 직접 root를 가리키도록 포인터를 바꿔준다.



Rank를 이용한 Union

Make-Set() 연산

> 유일한 멤버 x를 포함하는 새로운 집합을 생성하는 연산

```pseudocode
p[x] : 노드 x의 부모를 저장
rank[x] : 루트 노드가 x인 트리의 랭크 값 저장
Make-Set(x)
	p[x] <- x
	rank[x] <- 0
```



Find-Set() 연산

> x를 포함하는 집합을 찾는 오퍼레이션

```pseudocode
Find_Set(x)
	IF x =/= p[x] // x 가 루트가 아닌 경우
		p[x] <- Find_Set(p[x])
	RETURN p[x]
```



Union() 연산

> x,와 y 를 포함하는 두 집합을 통합

```pseudocode
Union(x, y)
	Link(Find_Set(x), Find_Set(Y))
	
Link(x, y)
	IF rank[x] > rank[y] // rank는 트리의 높이
		p[y] <- x
	ELSE
		p[x] <- y
		IF rank[x] == rank[y] // 둘의 랭크가 같다면
			rank[y] ++ // 한 쪽 랭크를 높여준다
```







최소 비용 신장 트리



- 그래프에서 최소 비용 문제
  - 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이뤄진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리
  - 무방향 가중치 그래프에서 신장 트리르 구성하는 간선들의 가중치의 합이 최소인 신장 트리



MST 표현



표현

- 인접행렬로 연결되어있는 경우 -> 가중치를 넣어줌

- 엣지에 대한 정보를 저장
- 부모 자식 관계와 가중치에 대한 배열





Prim 알고리즘

> 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어가는 방식



1. `임의 정점`을 하나 선택해서 시작 -> 어차피 모두 연결되어있기 때문에 어디든 상관 무
2. 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택
   - 선택한 정점 = MST에 포함된 정점
3. 모든 정점이 선택될 때 까지 1, 2 과정을 반복



- 서로소인 2개의 집합 정보를 유지
  - 트리 정점들 - MST를 만들기 위해 선택된 정점들
  - 비트리 정점들 - 선택 되지 않은 정점들



```pseudocode
MST_PRIM(G, r) // G : 그래프, r : 시작 정점
	FOR u in G.V
		u.key <- ∞ // u.key : u에 연결된 간선 중 최소 가중치 
		u.π <- NULL // u.π : 트리에서 u의 부모
	// 여기까진 초기화 과정
	r.key <- 0
	Q <- G.V // MST에 포함되지 않는 정점의 집합에 모든 정점 넣는다.
	WHILE Q =/= 0 // 빈 Q가 아니라면
		u <- Extract_MIN(Q) // key값이 가장 작은 정점 가져오기(r)
		FOR v in G.Adj[u] // u의 인접 정점들
			IF v ∈ Q AND w(u, v) < v.key // Q에 있는 v의 key 값
				v.π <- u 
				v.key <- w(u, v)
	// u에 인접하고 MST에 포함되지 않은 정점 중 가중치가 최소인 정점을 찾는 과정
```



0번 인덱스로 시작할 경우

연결된 정점 1 : 32 / 2 : 31 / 5: 60 / 6 : 51 -> 가장 작은 선택지 2번 `31`



2번 인덱스

연결된 정점 + 아까 0번 인덱스 연결안된 정점들 -> 가장 작은 선택지

=> 계속해서 선택지가 누적된다



KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘
  1. 최초, 모든 간선을 가중치에 따라 `오름차순`으로 정렬
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  3. n - 1개의 간선이 선택될 때까지 2번 반복



사이클 존재유무를 어떻게 찾는가?!



find-set을 이용하기

싸이클이 아니면 대표값을 갱신하기

0~6까지 있다면

원래는

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2    | 3    | 4    | 5    | 6    |

5 -3 이 18로 가중치가 제일 낮다

각 5와 3의 대표값을 확인해보기 -> 둘은 다르다

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | 2    | `5`  | 4    | 5    | 6    |

> 3의 대표값 -> 5로 변경



그다음 1 - 2 이 21로 가중치가 2번째로 낮다



| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 1    | `1`  | `5`  | 4    | 5    | 6    |

> 2의 대표값 -> 1로 변경



그 다음 2 - 6가 25로 가중치가 3번째로 낮다



| 0    | 1    | 2    | 3    | 4    | 5    | 6        |
| ---- | ---- | ---- | ---- | ---- | ---- | -------- |
| 0    | 1    | `1`  | `5`  | 4    | 5    | 2 -> `1` |

> 6의 대표값 -> 2로 변경 ==> 2는 곧 1이므로 대표값은 1



그 다음 0 - 2 가 31로 가중치가 4번째로 낮다

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | `0`  | `0`  | `5`  | 4    | 5    | `1`  |

> 2의 대표값 (1) 은 -> 0으로 변경
>
> 대표값이 1 역시 0 으로 변경됨



그다음 0 - 1가 32로 가중치 5번째로 낮다

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | `0`  | `0`  | `5`  | 4    | 5    | `1`  |

> 0과 1은 대표값이 같으므로 싸이클에 해당되므로 PASS



그 다음 3 - 4가 34로 가중치 6번째로 낮다

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | `0`  | `0`  | `5`  | `5`  | 5    | `1`  |

> 4의 대표값은 3으로
>
> 3의 대표값은 5이므로 4의 대표값은 곧 5가 된다



그 다음 5 - 4 가 40으로 가중치 7번째로 낮다

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | `0`  | `0`  | `5`  | `5`  | 5    | `1`  |

> 4와 5의 대표값이 같으므로 싸이클에 해당돼서 PASS



그 다음 2 - 4가 46으로 가중치 8번째로 낮다

| 0    | 1    | 2    | 3    | 4    | 5    | 6    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | `0`  | `0`  | `5`  | `0`  | `0`  | `1`  |

> 4의 대표값은 2가 된다 -> 2의 대표값은 0이다 => 4의 대표값은 0 이 된다.
>
> 4의 대표값인 5의 대표값도 0이 된다.

-- 종료 --



8번까지 돌며, 6개 선택 2개 PASS 

7개의 정점이라면 6개의 edge(간선)을 넣어주면 끝!



```pseudocode
MST-KRUSKAL(G, w)
	A <- 0 // 0 : 공집합
	FOR vertex v in G.V // G.V : 그래프 정점 집합
		Make_Set(v) // G.E : 그래프의 간선 집합
		
	G.E에 포함된 간선들을 가중치 w에 의해 정렬
	
	FOR 가중치가 가장 낮은 간선 (u, v) ∈ G.E 선택(n-1개)
		IF Find_Set(u) =/= Find_Set(v)
			A <- A ∪ {(u, v)}
			Union(u, v);
	RETURN A
```





최단경로

> 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로



하나의 시작 정점에서 끝 정점까지의 최단 경로

- 다익스트라 알고리즘
  - 음의 가중치를 허용하지 않음
- 벨만포드 알고리즘
  - 음의 가중치 허용



모든 정점들에 대한 최소 비용

- 플로이드 워샬 알고리즘







다익스트라 알고리즘

> 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식



시작 정점(s) 에서 끝 정점(t) 까지의 최단 경로에 정점 x가 존재

s - x 최단 경로 + x - t 최단경로로 구성

탐욕 기법 사용 / MST의 프림 알고리즘과 유사





```pseudocode
s: 시작 정점, A: 인접 행렬(정점 외엔 임의의 큰 수로) , D: 거리
v : 정점 집합, U: 선택된 정점 집합

Dijkstra(s, A, D)
	U = {s};
	
	FOR 모든 정점 v
		D[v] <- A[s][v]
		
	WHILE U =/= V
		D[w] 가 최소인 정점 w ∈ V - U를 선택
		U <- U ∪ {w}
		
		FOR w에 인접한 모든 정점 v
			D[v] <- min(D[v], D[w] + A[w][v])
```



생일파티 풀어보기 과제네 슈밤 ㅠㅡㅠ...!!

![image-20201104175614227](C:\Users\qbw00\AppData\Roaming\Typora\typora-user-images\image-20201104175614227.png)







BFS

D[] - 출발점에서 최단거리

p[] - 최단 경로 트리



|      | 1    | 2    | 3    | 4    | 5    | 6    | 7    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D    |      |      |      |      |      |      |      |
| P    |      |      |      |      |      |      |      |

u -> v

D[v] = D[u] + 1

p[v] = u





```python
for tc in range(1, 11): #
    N, s = ma(int, input().split())
    arr = list(map(int, input().split()))
    
    G = [[] for _ in range(101)]
    for i in range(0, N, 2):
        u, v = arr[i], arr[i + 1]
        G[u].append(v) # 유향이라 쌍방 넣어줄 필요 없음
    # 너비 우선 탐색
    visit = [0] * 101
    Q = [s]
    visit[s] = 1
    while Q:
        v = Q.pop(0)
        # v의 방문하지 않은 인접정점들
        for w in G[v]:
            if not visit[w]:
                visit[w] = visit[v] + 1
                Q.append(w)
    maxIdx = 1
    for i in range(2, 101):
        if visit[maxIdx] <= visit[i]:
            maxIdx = i
    print(maxIdx)
```



```python
for tc in range(1, 11): #
    N, E = ma(int, input().split())
   
    G = [[] for _ in range(101)]
    for _ in range(E):
        u, v, w = map(int, input().split())
        G[u].append([v, w])
        
    D = [0xfffffffff] * (N + 1) # 기존 visit 하고 다름! 거리 비교용! max값부터 시작
    D[0] = 0
    Q = [0]
    
    while Q:
        u = Q.pop(0)
        for v, w in G[u]:
            if D[v] > D[u] + w:
                D[v] = D[u] + w
                Q.append(v)
    print(D[N])
```

```
6 5
1 2
1 3
3 4
2 3
4 5
```