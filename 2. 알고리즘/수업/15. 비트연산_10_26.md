비트연산

- 1<<n == 2^n

| b n  | b n-1   | ...  | b 3  | b 2  | b 1  | b 0  |
| ---- | ------- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0       |      | 0    | 0    | 0    | 1    |
| 2^n  | 2^(n-1) |      | 2^3  | 2^2  | 2^1  | 2^0  |

> 1<<0 인 경우는 2^0 == 1



원소가 n개일 경우의 모든 부분집합의 수를 의미한다

power set(모든 부분집합) : 공집합과 나를 포함한 모든 부분집합

​	각 원소가 포함되는 경우, 포함되지 않는 경우(2가지) -> 총 n번 곱하기



i `&` (`1 << j`) :  i의 j번 비트가 1인지 0인지 검사

​	i << j : j번 비트가 1인 값

​	& : 하나라도 0이면 = 0, 둘 다 1이면 = 1



`|` : or 덧셈과 같다

1 << 4 | 1 << 3:

1 0 0 0 0

​	1 0 0 0

1 1 0 0 0



```python
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1 << j) else "0"
    print(output)
    
for i in range(-5, 6):
    print('{} ='.format(i), end='')
          Bbit_print(i)
          
'''
-5 = 1 1 1 1 1 0 1 1
-4 = 1 1 1 1 1 1 0 0
-3 = 1 1 1 1 1 1 0 1
-2 = 1 1 1 1 1 1 1 0
-1 = 1 1 1 1 1 1 1 1
0 = 0 0 0 0 0 0 0 0
1 = 0 0 0 0 0 0 0 1
2 = 0 0 0 0 0 0 1 0
3 = 0 0 0 0 0 0 1 1
4 = 0 0 0 0 0 1 0 0
5 = 0 0 0 0 0 1 0 1
'''
```



```python
def Bbit_print(i):
    output = ""
    for j in range(7, -1, -1):
        output += "1" if i & (1 << j) else "0"
    print(output)
    
a = 0x10
x = 0x01020304
print('{} ='.format(a), end=" ")
Bbit_print(a)
print()
print('{} ='.format(x), end=" ")
for i in range(0, 4):
    Bbit_print((x >> i*8) & 0xff)
    
'''
16 = 00010000
01020304 = 00000100 00000011 00000010 00000001
'''
```

> `>>` 은 나눗셈과 같다 / 2의 제곱수를 나눠주는..!



엔디안(Endianness)

- 컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법
- HW 아키텍쳐마다 다르다
- 속도 향상을 위해 바이트 단위와 워드 단위를 변환하여 연산할 때 올바로 이해하지 안흥면 오류를 발생 시킬 수 있다.



빅엔디안

- 보통 큰 단위가 앞에 나옴. 네트워크

리틀엔디안

- 작은 단위가 앞에 나옴. 대다수 데스크탑 컴퓨터



| 종류        | 0x1234의 표현 | 0x12345678의 표현 |
| ----------- | ------------- | ----------------- |
| 빅 엔디안   | 12 34         | 12 34 56 78       |
| 리틀 엔디안 | 34 12         | 78 56 34 12       |



```python
n = 0x00111111 # 00 11 11 11

if n & 0xff:
    print("little endian")
else:
    print("big endian")
```





```python
def ce(n): # change endian
    p = []
    for i in range(0, 4):
        p.append((n >> (24 = i * 8)) & 0xff)
    return p

x = 0x01020304
p = []
for i in range(0, 4):
    p.append((x >> (i * 8)) & 0xff)
    
print('x = {}{}{}{}'.format(p[0], p[1], [2], p[3]))
p = ce(x)
print('x = {}{}{}{}'.format(p[0], p[1], [2], p[3]))
```



```python

```





실습

