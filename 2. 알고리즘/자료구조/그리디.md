# 그리디

- 매 단계에서 가장 좋아 보이는 것을 빠르게 선택한다. (지역 최적 선택)
- 하위 문제를 풀기 전에 선택이 먼저 이뤄진다.
- Top-down 방식
- 일반적으로 빠르고 간결하다



### 배낭문제

- S = 물건들의 집합
- w : item 무게
- P = item 의 값
- W : 배낭이 수용가능한 총 무게
- w로 구성된 집합 A 는 W 보다 작지만, A의 P는 최대가 되는 S의 부분집합 -> A를 구하시오.

- 0 - 1 배낭문제

  - 배낭에 물건을 통째로 담아야하는 문제
  - 문제를 쪼갤 수 없다.
  - 완전 검색

  ```
  - 완전 검색으로 물건들의 집합 S에 대한 모든 부분집합을 구한다.
  - 부분집합의 총 무게가 W를 초과하는 집합은 버리고, 나머지 집합 중 P가 최대가 되는 집합 선택
  - 물건 개수 증가시 시간복잡도는 `지수`적으로 증가
  ```

  

  - 탐욕적

  ```
  1. 비싼 물건부터 채우기
  - W 보다 무게가 작은 물건 중 최대로 구성하기
  - 최적해를 구할 수 없다.
  
  2. 가벼운 물건부터 채우기
  - 위와 마찬가지로 최적해 구할 수 없다.
  
  3. 무게당 값이 높은 순서로 물건 채우기
  - 마찬가지로 최적해 구하기 불가능
  ```

  > 탐욕적 방법으로 배낭문제는 최적해를 구할 수 없다.



- Fractional 배낭

  - 부분적으로 담는 것이 허용된다.
  - 물건을 쪼갤 수 있다.

  

  - 탐욕적

  ```
  물건을 쪼갤 수 있는 경우, 무게당 가치를 얻을 수 있기 때문에
  무게당 값이 높은 순서로 물건 채우기 => 최적해 구하기 가능
  ```

  



### 활동 선택 문제

- 회의실 배정
- n개의 활동들의 집합(각 활동은 시작시간과 종료시간이 있다.)
- 서로 시간이 겹치지 않는 최대개수의 활동들의 집합을 구하는 문제



- S[0:n+1] = a(0)의 종료시간부터 a(n+1)의 시작시간 사이에 포함된 활동들



- 탐욕법

```
공집합이 아닌 문제 S[i][j]. S[i][j] 에 속한 활동 a(m) 은 종료시간이 가장 빠른 활동
a(m)을 선택하면,
S[i][m] 은 공집합이 되고, S[m][j] 라는 하위문제가 남는다. -> 하위문제에서 위의 과정을 반복

1. S[0][n-1] 에 대해 종료시간이 가장 빠른 a[i] 를 선택
2. S[i][n-1] 에 대해 종료시간이 가장 빠른 a[j] 를 선택
3. s[j][n-1] 에 대해 종료시간이 가장 빠른 a[k] 를 선택 ..... 반복
```



- 탐욕 기법을 적용한 반복 알고리즘

```python
# 1. 종료 시간이 빠른 순서로 활동들 정렬
# 2. 첫번째 활동을 선택하고 해집합에 포함
# 3. 선택한 활동의 종료시간보다 빠른 시작 시간을 가지는 활동들은 모두 제거
# 4. 남은 활동들에 대해 앞의 과정 반복

# A: 정렬된 활동들의 집합 , S: 선택된 활동들의 집합
# si: 시작시간, fi: 종료시간, 1 <= i <= n

S = {a1}
j = 1
for i in range(2, n+1):
    if si >= fi:
        S = S.append(ai)
        j = i
```



- 탐욕 알고리즘이 최적해를 구한다는 것에 대한 증명
  - 탐욕적 선택 속성
    - 탐욕적 선택은 항상 안전하다는 것을 보여야함
    - 
  - 최적 부분 구조 : 하나의 선택을 하면 풀어야할 하위 문제가 남는다. 
    - 원문제 최적해 = 탐욕적 선택 + 하위 문제의 최적해

