# 10989. 수 정렬하기 3

N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.

(input 데이터에 중복되는 숫자가 존재한다. `카운팅 정렬` 사용이 권장된다.)



#### 카운팅 정렬

 input 데이터를 순회하며, 해당 데이터의 갯수를 새로운 배열을 생성하여, 그 배열의 인덱스에 넣어준다.

존재하지 않는 경우 -1 (그러므로 첫 배열 생성시엔 전부 -1로 된 배열을 만들어준다.)

갯수에 대한 배열이 완성되면 인덱스를 순회하며, 갯수만큼 출력한다.

```python
def counting_sort(array, max):
    
    counting_array = [0] * (max + 1)
    
    for i in array:
        counting_array[i] += 1
    
    for i in range(max):
        counting_array[i+1] += counting_array[i]
    
    output_array  = [-1] * len(array)
    
    for i in array:
        output_array[counting_array[i] - 1] = i
        counting_array[i] -= 1
    return output_array
```



#### 풀이

```python
import sys

def counting_sort(array, max):
    counting_array = [0] * (max + 1)

    for i in array:
        counting_array[i] += 1

    for i in range(max):
        counting_array[i + 1] += counting_array[i]

    output_array = [-1] * len(array)

    for i in array:
        output_array[counting_array[i] - 1] = i
        counting_array[i] -= 1

    return output_array

s = sys.stdin.readline

N = int(s())
arr = list(int(s()) for _ in range(N))

ans = counting_sort(arr, max(arr))

print(*ans, sep='\n')
```

> 메모리 초과

```python
import sys
s = sys.stdin.readline

N = int(s())
cnt = [0 for _ in range(10001)]
for _ in range(N):
    cnt[int(s())] += 1

for i in range(10001):
    for j in range(cnt[i]):
        print(i)
```

> 시간 단축을 위해 카운팅 정렬을 썼으나, 리스트를 반복사용했던 것이 문제
>
> 하나의 리스트로 입력부터 해결하니 통과되었다.