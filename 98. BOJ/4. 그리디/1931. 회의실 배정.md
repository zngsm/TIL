# 1931. 회의실 배정

한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.



### 풀이
그리디는 매 순간순간 최적 해를 선택해야한다.
시작시간, 끝시간을 튜플 형태로 배열화하고, 끝시간 기준으로 sort를 한다.
정렬된 배열을 활용해서, 남은 시간 중 가장 빠른 인덱스를 ans에 추가한다.
추가되면 남은 시간은 ans 추가된 값의 끝 시간 을 기준으로 다시 산정된다

```python
import sys; sys.stdin = open("input_1931.txt", "r")
s = sys.stdin.readline
N = int(s())
arr = [tuple(map(int, s().split())) for _ in range(N)]
arr = sorted(arr, key = lambda x : (x[1], x[0]))
i = 0
start = -1
ans = []
while True:
    if not arr:
        break
    if start == 2 ** 31 - 1:
        break
    A = arr.pop(0)
    if A[0] >= start:
        ans.append(A)
        start = A[1]
print(len(ans))
```

> 오답이 여러번 발생하였다. pop 을 써서 속도가 다소 느렸다. 크기에 맞춰 인덱스를 맞춰놓고 진행해도 될 듯?
>
> 첫번째 반례
>
> ```
> 1
> 0 0
> > 1
> start 지점을 0 으로 주고 if A[0] > start: 로 조건을 줘서 ans = 0 으로 출력
> start 를 -1로 변경
> ```
>
> 두번째 반례
>
> ```
> 3
> 1 4
> 4 8
> 3 5
> > 2
> 위의 if A[0] > start: 조건으로 인해 1 4 -> 4 8 로 연결되지 못하고 1 4 만 선택 후 종료하게 된다.
> if A[0] >= start: 로 변경하니 해결되었다. 첫번째 문제도 사실 이 조건이었으면 다 해결되었을 듯
> ```
>
> 세번째 반례
>
> ```
> 5
> 4 5
> 4 4
> 3 4
> 2 5
> 1 3
> > 4
> 정렬시 조건을 arr = sorted(arr, key = lambda x : x[1]) 로 주었었다. 그 결과 4 4 다음에 3 4 가 오게 되어, 인덱스 순서대로 정답에 추가하다보니 4 4 가 먼저 추가되어 3 4를 통과하게 되었다.
> arr = sorted(arr, key = lambda x : (x[1], x[0])) 조건을 이와 같이 끝 시간 기준이나, 두번째로는 시작 시간 기준으로 다중조건을 걸어줘서 해결
> ```